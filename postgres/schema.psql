-- TimeStamp functions
-- This trigger function will set the created_at value on insert
CREATE OR REPLACE FUNCTION set_created_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.created_at = now();
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';
-- usage example
-- CREATE TRIGGER auth_account_set_created_at BEFORE INSERT ON auth.account
--     FOR EACH ROW EXECUTE FUNCTION set_created_at();


-- This trigger function will set the updated_at value if an update changes any values
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    IF row(NEW.*) IS DISTINCT FROM row(OLD.*) THEN
        NEW.updated_at = now();
        RETURN NEW;
    ELSE
        RETURN OLD;
    END IF;
END;
$$ language 'plpgsql';

-- uage example
-- CREATE TRIGGER auth_account_set_updated_at BEFORE UPDATE ON auth.account
--     FOR EACH ROW EXECUTE FUNCTION set_updated_at();


drop schema if exists auth cascade;
create schema auth;

-- Password Hashing trigger Function
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE OR REPLACE FUNCTION auth.hash_password()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.password IS NOT NULL THEN
        NEW.password = crypt(NEW.password, gen_salt('bf'));
    END IF;
    RETURN NEW;
END;
$$ language 'plpgsql';

create table auth.account (
    account_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
CREATE TRIGGER auth_account_hash_password BEFORE INSERT OR UPDATE ON auth.account
    FOR EACH ROW EXECUTE FUNCTION auth.hash_password();

CREATE TRIGGER auth_account_set_created_at BEFORE INSERT ON auth.account
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER auth_account_set_updated_at BEFORE UPDATE ON auth.account
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();


create table auth.role (
    role_name TEXT PRIMARY KEY,
    description TEXT
);
create table auth.privilege (
    account_id UUID REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    role_name TEXT REFERENCES auth.role (role_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    PRIMARY KEY (account_id, role_name)
);

insert into auth.role
  (role_name, description)
values
  ('auth-administrator', 'Administrator role description'),
  ('auth-user', 'Auth-User role description');
insert into auth.account
  (username, password)
values
  ('admin', 'admin'),
  ('user', '');

-- COMMENT ON TABLE auth.account IS 'Account Table used for auth';

drop schema if exists support cascade;
create schema support;

create table support.area (
    area_name TEXT PRIMARY KEY,
    description TEXT
);
create table support.category (
    category_name TEXT PRIMARY KEY,
    description TEXT
);
create table support.status (
    status_name TEXT PRIMARY KEY,
    description TEXT
);
create table support.priority (
    priority_name TEXT PRIMARY KEY,
    description TEXT
);
create table support.tag (
    tag_name TEXT PRIMARY KEY,
    description TEXT
);
create table support.ticket (
    ticket_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title TEXT,
    body TEXT,
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    area_name TEXT REFERENCES support.area (area_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    category_name TEXT NOT NULL REFERENCES support.category (category_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    status_name TEXT NOT NULL REFERENCES support.status (status_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    priority_name TEXT REFERENCES support.priority (priority_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
CREATE TRIGGER support_ticket_set_created_at BEFORE INSERT ON support.ticket
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER support_ticket_set_updated_at BEFORE UPDATE ON support.ticket
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

create table support.ticket_tag (
    tag_name TEXT REFERENCES support.tag (tag_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    ticket_id UUID REFERENCES support.ticket (ticket_id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    PRIMARY KEY (tag_name, ticket_id)
);
create table support.ticket_entry (
    ticket_entry_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ticket_id UUID NOT NULL REFERENCES support.ticket (ticket_id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    body TEXT,
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    area_name TEXT REFERENCES support.area (area_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    category_name TEXT REFERENCES support.category (category_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    status_name TEXT REFERENCES support.status (status_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    priority_name TEXT REFERENCES support.priority (priority_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

CREATE TRIGGER support_ticket_entry_set_created_at BEFORE INSERT ON support.ticket_entry
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER support_ticket_entry_set_updated_at BEFORE UPDATE ON support.ticket_entry
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- update ticket status, priority, category
CREATE OR REPLACE FUNCTION support.ticket_entry_update_ticket()
RETURNS TRIGGER AS $$
BEGIN
    IF
        NEW.status_name IS NOT NULL OR
        NEW.priority_name IS NOT NULL OR
        NEW.area_name IS NOT NULL OR
        NEW.category_name IS NOT NULL
    THEN
        UPDATE support.ticket SET
            status_name = COALESCE(NEW.status_name, status_name),
            priority_name = COALESCE(NEW.priority_name, priority_name),
            area_name = COALESCE(NEW.area_name, area_name),
            category_name = COALESCE(NEW.category_name, category_name)
        WHERE support.ticket.ticket_id = NEW.ticket_id;
    END IF;
    RETURN NEW;
END;
$$ language 'plpgsql';
CREATE TRIGGER support_ticket_entry_update_ticket BEFORE INSERT ON support.ticket_entry
    FOR EACH ROW EXECUTE FUNCTION support.ticket_entry_update_ticket();

drop schema if exists admittance cascade;
create schema admittance;

CREATE TABLE admittance.series (
    series_name TEXT PRIMARY KEY,
    description TEXT NOT NULL,
    color TEXT NOT NULL,
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

CREATE TRIGGER admittance_series_set_created_at BEFORE INSERT ON admittance.series
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER admittance_series_set_updated_at BEFORE UPDATE ON admittance.series
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TABLE admittance.bracelet (
    bracelet_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    series_name TEXT REFERENCES admittance.series (series_name)
        ON UPDATE RESTRICT
        ON DELETE RESTRICT,
    serial BIGINT NOT NULL CHECK (serial > 0),
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    UNIQUE (series_name, serial)
);

CREATE TRIGGER admittance_admittance_set_created_at BEFORE INSERT ON admittance.bracelet
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER admittance_admittance_set_updated_at BEFORE UPDATE ON admittance.bracelet
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TABLE admittance.checkpoint (
    checkpoint_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    checkpoint_name TEXT UNIQUE NOT NULL,
    description TEXT
);

CREATE TABLE admittance.product (
    product_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    product_name TEXT UNIQUE NOT NULL,
    description TEXT,
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

CREATE TRIGGER admittance_product_set_created_at BEFORE INSERT ON admittance.product
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER admittance_product_set_updated_at BEFORE UPDATE ON admittance.product
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TABLE admittance.product_checkpoint (
    product_id UUID NOT NULL REFERENCES admittance.product (product_id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    checkpoint_id UUID NOT NULL REFERENCES admittance.checkpoint (checkpoint_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    PRIMARY KEY (product_id, checkpoint_id)
);

CREATE TABLE admittance.assignation (
    assignation_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    bracelet_id UUID NOT NULL REFERENCES admittance.bracelet (bracelet_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    valid_from TIMESTAMP WITH TIME ZONE NOT NULL,
    valid_to TIMESTAMP WITH TIME ZONE NOT NULL,
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    CHECK (valid_from < valid_to)
);

CREATE TRIGGER admittance_assignation_set_created_at BEFORE INSERT ON admittance.assignation
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER admittance_assignation_set_updated_at BEFORE UPDATE ON admittance.assignation
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TABLE admittance.assignation_cancelation (
    assignation_cancelation_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    assignation_id UUID NOT NULL REFERENCES admittance.assignation (assignation_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    description TEXT,
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

CREATE TABLE admittance.assignation_product (
    assignation_id UUID NOT NULL REFERENCES admittance.assignation (assignation_id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES admittance.product (product_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    PRIMARY KEY (assignation_id, product_id)
);

CREATE TABLE admittance.activation (
    activation_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    bracelet_id UUID NOT NULL REFERENCES admittance.bracelet (bracelet_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    checkpoint_id UUID NOT NULL REFERENCES admittance.checkpoint (checkpoint_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    datetime TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

CREATE TRIGGER admittance_activation_set_created_at BEFORE INSERT ON admittance.activation
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER admittance_activation_set_updated_at BEFORE UPDATE ON admittance.activation
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();


CREATE OR REPLACE FUNCTION admittance.activation_validation()
RETURNS TRIGGER AS $$
BEGIN
    NEW.datetime = NOW();
    -- check if activations from other dates exist
    IF EXISTS (
        SELECT 1 FROM admittance.activation
        WHERE bracelet_id = NEW.bracelet_id
        AND NOT datetime <= CURRENT_DATE
        AND NOT datetime >= (CURRENT_DATE + INTERVAL '1 day')
    ) THEN
        RAISE EXCEPTION 'This bracelet has already been activated on a diferent date';
    END IF;
    -- Join assignation to checkpoint using product
    -- match bracelet and checkpoint
    -- match valid_from and valid_to
    -- check if assignation not cancelled
    IF NOT EXISTS (
        SELECT 1 FROM admittance.assignation
            LEFT JOIN admittance.assignation_product
            ON admittance.assignation_product.assignation_id = admittance.assignation.assignation_id
            LEFT JOIN admittance.product_checkpoint
            ON admittance.assignation_product.product_id = admittance.product_checkpoint.product_id
        WHERE
            admittance.assignation.bracelet_id = NEW.bracelet_id
            AND admittance.product_checkpoint.checkpoint_id = NEW.checkpoint_id
            AND admittance.assignation.valid_from <= NOW()
            AND admittance.assignation.valid_to >= NOW()
            AND NOT EXISTS (SELECT 1 FROM admittance.assignation_cancelation WHERE assignation_id = assignation.assignation_id)
    ) THEN
        RAISE EXCEPTION 'This bracelet is either invalid, expired or unassigned';
    END IF;
    RETURN NEW;
END;
$$ language 'plpgsql';
CREATE TRIGGER admittance_verify_activation_validation BEFORE INSERT ON admittance.activation
    FOR EACH ROW EXECUTE FUNCTION admittance.activation_validation();
-- DO $$
-- BEGIN
--     FOR counter IN 1..500 LOOP
--         INSERT INTO admittance.bracelet (series, serial) VALUES ('110', counter);
--     END LOOP;
-- END; $$
