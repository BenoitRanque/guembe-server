-- TimeStamp functions
-- This trigger function will set the created_at value on insert
CREATE OR REPLACE FUNCTION set_created_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.created_at = now();
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';
-- usage example
-- CREATE TRIGGER auth_account_set_created_at BEFORE INSERT ON auth.account
--     FOR EACH ROW EXECUTE FUNCTION set_created_at();


-- This trigger function will set the updated_at value if an update changes any values
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    IF row(NEW.*) IS DISTINCT FROM row(OLD.*) THEN
        NEW.updated_at = now();
        RETURN NEW;
    ELSE
        RETURN OLD;
    END IF;
END;
$$ language 'plpgsql';

-- uage example
-- CREATE TRIGGER auth_account_set_updated_at BEFORE UPDATE ON auth.account
--     FOR EACH ROW EXECUTE FUNCTION set_updated_at();


drop schema if exists auth cascade;
create schema auth;

-- Password Hashing trigger Function
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE OR REPLACE FUNCTION auth.hash_password()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.password IS NOT NULL THEN
        NEW.password = crypt(NEW.password, gen_salt('bf'));
    END IF;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TABLE auth.account (
    account_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
CREATE TRIGGER auth_account_hash_password BEFORE INSERT OR UPDATE ON auth.account
    FOR EACH ROW EXECUTE FUNCTION auth.hash_password();

CREATE TRIGGER auth_account_set_created_at BEFORE INSERT ON auth.account
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER auth_account_set_updated_at BEFORE UPDATE ON auth.account
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();


CREATE TABLE auth.role (
    role_name TEXT PRIMARY KEY,
    description TEXT
);
CREATE TABLE auth.account_role (
    account_id UUID REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    role_name TEXT REFERENCES auth.role (role_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    PRIMARY KEY (account_id, role_name)
);


WITH administrator_account AS (
    INSERT INTO auth.account
        (username, password)
    VALUES
        ('admin', 'admin')
    RETURNING account_id
), auth_roles AS (
    INSERT INTO auth.role
        (role_name, description)
    VALUES
        ('admin', 'Usuario administrador maximo. No utilizar en productivo'),
        ('support-client', 'Usuario de sopport. Puede crear tickets, ver y responder a tickets creados por si mismo, y cerrar o reabrir dichos tickets'),
        ('support-technician', 'Usuario de sopporte. Puede ver, editar, responder, y cerrar todos los tickets. Recibe notificacion cuando se le asigna un ticket.'),
        ('support-manager', 'Usuario de sopporte. Puede asignar tickets a usuarios.'),
        ('support-supervisor', 'Usuario de sopporte. Puede leer todos los tickets.')
    RETURNING role_name
)
INSERT INTO auth.account_role
    (account_id, role_name)
SELECT
    account_id, role_name
FROM administrator_account CROSS JOIN auth_roles;

-- COMMENT ON TABLE auth.account IS 'Account Table used for auth';

drop schema if exists support cascade;
create schema support;

CREATE TABLE support.status (
    status_name TEXT PRIMARY KEY,
    description TEXT
);

INSERT INTO support.status
    (status_name, description)
VALUES
    ('OPEN', 'Abierto'),
    ('CLOSED', 'Cerrado'),
    ('PENDING', 'Pendiente');

CREATE TABLE support.priority (
    priority_name TEXT PRIMARY KEY,
    description TEXT
);

INSERT INTO support.priority
    (priority_name, description)
VALUES
    ('HIGH', 'Alta'),
    ('MEDIUM', 'Media'),
    ('LOW', 'Baja');

CREATE TABLE support.tag (
    tag_name TEXT PRIMARY KEY,
    description TEXT
);

INSERT INTO support.tag
    (tag_name, description)
VALUES
    ('Impresora', 'Problemas de impresoras'),
    ('SAP', 'Problemas de SAP'),
    ('RetailOne', 'Problemas de Retail One'),
    ('Hotel', 'Area Hotelera'),
    ('Contabilidad', 'Area Contable'),
    ('Restaurante', 'Area Restaurante'),
    ('Comercial', 'Area Comercial');

CREATE TABLE support.account_default_tag (
    account_id UUID REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    tag_name TEXT REFERENCES support.tag (tag_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    PRIMARY KEY (account_id, tag_name)
);

CREATE TABLE support.ticket (
    ticket_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title TEXT,
    body TEXT,
    status_name TEXT DEFAULT 'OPEN' NOT NULL REFERENCES support.status (status_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    priority_name TEXT DEFAULT 'MEDIUM' NOT NULL REFERENCES support.priority (priority_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
CREATE TRIGGER support_ticket_set_created_at BEFORE INSERT ON support.ticket
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER support_ticket_set_updated_at BEFORE UPDATE ON support.ticket
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TABLE support.ticket_tag (
    ticket_id UUID REFERENCES support.ticket (ticket_id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    tag_name TEXT REFERENCES support.tag (tag_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    PRIMARY KEY (ticket_id, tag_name)
);

CREATE TABLE support.ticket_entry (
    ticket_entry_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ticket_id UUID NOT NULL REFERENCES support.ticket (ticket_id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    body TEXT,
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
CREATE TRIGGER support_ticket_entry_set_created_at BEFORE INSERT ON support.ticket_entry
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER support_ticket_entry_set_updated_at BEFORE UPDATE ON support.ticket_entry
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TABLE support.ticket_status (
    ticket_status_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ticket_id UUID NOT NULL REFERENCES support.ticket (ticket_id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    status_name TEXT REFERENCES support.status (status_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
CREATE TRIGGER support_ticket_status_set_created_at BEFORE INSERT ON support.ticket_status
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER support_ticket_status_set_updated_at BEFORE UPDATE ON support.ticket_status
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();
-- update ticket status
CREATE OR REPLACE FUNCTION support.ticket_status_update()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE support.ticket
    SET status_name = NEW.status_name
    WHERE support.ticket.ticket_id = NEW.ticket_id;
    RETURN NEW;
END;
$$ language 'plpgsql';
CREATE TRIGGER support_ticket_status_update BEFORE INSERT ON support.ticket_status
    FOR EACH ROW EXECUTE FUNCTION support.ticket_status_update();

CREATE TABLE support.ticket_priority (
    ticket_priority_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ticket_id UUID NOT NULL REFERENCES support.ticket (ticket_id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    priority_name TEXT NOT NULL REFERENCES support.priority (priority_name)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
CREATE TRIGGER support_ticket_priority_set_created_at BEFORE INSERT ON support.ticket_priority
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER support_ticket_priority_set_updated_at BEFORE UPDATE ON support.ticket_priority
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();
-- update ticket priority
CREATE OR REPLACE FUNCTION support.ticket_priority_update()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE support.ticket
    SET priority_name = NEW.priority_name
    WHERE support.ticket.ticket_id = NEW.ticket_id;
    RETURN NEW;
END;
$$ language 'plpgsql';
CREATE TRIGGER support_ticket_priority_update BEFORE INSERT ON support.ticket_priority
    FOR EACH ROW EXECUTE FUNCTION support.ticket_priority_update();

CREATE TABLE support.ticket_assignation (
    ticket_assignation_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ticket_id UUID NOT NULL REFERENCES support.ticket (ticket_id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    assignee_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
CREATE TRIGGER support_ticket_assignation_set_created_at BEFORE INSERT ON support.ticket_assignation
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER support_ticket_assignation_set_updated_at BEFORE UPDATE ON support.ticket_assignation
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TABLE support.attachement (
    attachement_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    path TEXT NOT NULL,
    name TEXT NOT NULL,
    type TEXT NOT null,
    size BIGINT NOT NULL,
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
CREATE TRIGGER support_attachement_set_created_at BEFORE INSERT ON support.attachement
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER support_attachement_set_updated_at BEFORE UPDATE ON support.attachement
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- CREATE VIEW support.ticket_thread AS
-- SELECT
--     COALESCE(support.ticket_entry.ticket_id, support.ticket_status.ticket_id, support.ticket_priority.ticket_id, support.ticket_assignation.ticket_id) as ticket_id,
--     COALESCE(support.ticket_entry.owner_id, support.ticket_status.owner_id, support.ticket_priority.owner_id, support.ticket_assignation.owner_id) as owner_id,
--     COALESCE(support.ticket_entry.created_at, support.ticket_status.created_at, support.ticket_priority.created_at, support.ticket_assignation.created_at) as created_at,
--     COALESCE(support.ticket_entry.updated_at, support.ticket_status.updated_at, support.ticket_priority.updated_at, support.ticket_assignation.updated_at) as updated_at,
--     support.ticket_entry.ticket_entry_id,
--     support.ticket_entry.body,
--     support.ticket_status.ticket_status_id,
--     support.ticket_status.status_name,
--     support.ticket_priority.ticket_priority_id,
--     support.ticket_priority.priority_name,
--     support.ticket_assignation.ticket_assignation_id,
--     support.ticket_assignation.assignee_id
-- FROM support.ticket_entry
-- CROSS JOIN support.ticket_status
-- CROSS JOIN support.ticket_priority
-- CROSS JOIN support.ticket_assignation;
-- (SELECT
--     ticket_id,
--     owner_id,
--     created_at,
--     updated_at,
--     ticket_entry_id,
--     body,
--     null as ticket_status_id,
--     null as status_name,
--     null as ticket_priority_id,
--     null as priority_name,
--     null as ticket_assignation_id,
--     null as assignee_id
-- FROM support.ticket_entry)
-- UNION ALL
-- (SELECT
--     ticket_id,
--     owner_id,
--     created_at,
--     updated_at,
--     null as ticket_entry_id,
--     null as body,
--     null as ticket_status_id,
--     null as status_name,
--     null as ticket_priority_id,
--     null as priority_name,
--     null as ticket_assignation_id,
--     null as assignee_id
-- FROM support.ticket_status)
-- UNION ALL
-- (SELECT
--     ticket_id,
--     owner_id,
--     created_at,
--     updated_at,
--     null as ticket_entry_id,
--     null as body,
--     null as ticket_status_id,
--     null as status_name,
--     null as ticket_priority_id,
--     null as priority_name,
--     null as ticket_assignation_id,
--     null as assignee_id
-- FROM support.ticket_priority)
-- UNION ALL
-- (SELECT
--     ticket_id,
--     owner_id,
--     created_at,
--     updated_at,
--     null as ticket_entry_id,
--     null as body,
--     null as ticket_status_id,
--     null as status_name,
--     null as ticket_priority_id,
--     null as priority_name,
--     null as ticket_assignation_id,
--     null as assignee_id
-- FROM support.ticket_assignation)
-- ORDER BY created_at ASC;
-- CREATE VIEW support.ticket_thread AS
-- (SELECT ticket_id, ticket_entry_id, null, null, null, body, null, null, null, owner_id, created_at, updated_at FROM support.ticket_entry)
-- UNION ALL
-- (SELECT ticket_id, null, ticket_status_id, null, null, null, status_name, null, null, owner_id, created_at, updated_at FROM support.ticket_status)
-- UNION ALL
-- (SELECT ticket_id, null, null, ticket_priority_id, null, null, null, priority_name, null, owner_id, created_at, updated_at FROM support.ticket_priority)
-- UNION ALL
-- (SELECT ticket_id, null, null, null, ticket_assignation_id, null, null, null, assignee_id, owner_id, created_at, updated_at FROM support.ticket_assignation)
-- ORDER BY created_at ASC;

drop schema if exists admittance cascade;
create schema admittance;

CREATE TABLE admittance.series (
    series_name TEXT PRIMARY KEY,
    description TEXT NOT NULL,
    color TEXT NOT NULL,
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

CREATE TRIGGER admittance_series_set_created_at BEFORE INSERT ON admittance.series
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER admittance_series_set_updated_at BEFORE UPDATE ON admittance.series
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TABLE admittance.bracelet (
    bracelet_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    series_name TEXT REFERENCES admittance.series (series_name)
        ON UPDATE RESTRICT
        ON DELETE RESTRICT,
    serial BIGINT NOT NULL CHECK (serial > 0),
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    UNIQUE (series_name, serial)
);

CREATE TRIGGER admittance_admittance_set_created_at BEFORE INSERT ON admittance.bracelet
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER admittance_admittance_set_updated_at BEFORE UPDATE ON admittance.bracelet
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TABLE admittance.checkpoint (
    checkpoint_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    checkpoint_name TEXT UNIQUE NOT NULL,
    description TEXT
);

CREATE TABLE admittance.product (
    product_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    product_name TEXT UNIQUE NOT NULL,
    description TEXT,
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

CREATE TRIGGER admittance_product_set_created_at BEFORE INSERT ON admittance.product
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER admittance_product_set_updated_at BEFORE UPDATE ON admittance.product
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TABLE admittance.product_checkpoint (
    product_id UUID NOT NULL REFERENCES admittance.product (product_id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    checkpoint_id UUID NOT NULL REFERENCES admittance.checkpoint (checkpoint_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    PRIMARY KEY (product_id, checkpoint_id)
);

CREATE TABLE admittance.assignation (
    assignation_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    bracelet_id UUID NOT NULL REFERENCES admittance.bracelet (bracelet_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    valid_from TIMESTAMP WITH TIME ZONE NOT NULL,
    valid_to TIMESTAMP WITH TIME ZONE NOT NULL,
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    CHECK (valid_from < valid_to)
);

CREATE TRIGGER admittance_assignation_set_created_at BEFORE INSERT ON admittance.assignation
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER admittance_assignation_set_updated_at BEFORE UPDATE ON admittance.assignation
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TABLE admittance.assignation_cancelation (
    assignation_cancelation_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    assignation_id UUID NOT NULL REFERENCES admittance.assignation (assignation_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    description TEXT,
    owner_id UUID NOT NULL REFERENCES auth.account (account_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

CREATE TABLE admittance.assignation_product (
    assignation_id UUID NOT NULL REFERENCES admittance.assignation (assignation_id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES admittance.product (product_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    PRIMARY KEY (assignation_id, product_id)
);

CREATE TABLE admittance.activation (
    activation_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    bracelet_id UUID NOT NULL REFERENCES admittance.bracelet (bracelet_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    checkpoint_id UUID NOT NULL REFERENCES admittance.checkpoint (checkpoint_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    datetime TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

CREATE TRIGGER admittance_activation_set_created_at BEFORE INSERT ON admittance.activation
    FOR EACH ROW EXECUTE FUNCTION set_created_at();
CREATE TRIGGER admittance_activation_set_updated_at BEFORE UPDATE ON admittance.activation
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();


CREATE OR REPLACE FUNCTION admittance.activation_validation()
RETURNS TRIGGER AS $$
BEGIN
    NEW.datetime = NOW();
    -- check if activations from other dates exist
    IF EXISTS (
        SELECT 1 FROM admittance.activation
        WHERE bracelet_id = NEW.bracelet_id
        AND NOT datetime <= CURRENT_DATE
        AND NOT datetime >= (CURRENT_DATE + INTERVAL '1 day')
    ) THEN
        RAISE EXCEPTION 'This bracelet has already been activated on a diferent date';
    END IF;
    -- Join assignation to checkpoint using product
    -- match bracelet and checkpoint
    -- match valid_from and valid_to
    -- check if assignation not cancelled
    IF NOT EXISTS (
        SELECT 1 FROM admittance.assignation
            LEFT JOIN admittance.assignation_product
            ON admittance.assignation_product.assignation_id = admittance.assignation.assignation_id
            LEFT JOIN admittance.product_checkpoint
            ON admittance.assignation_product.product_id = admittance.product_checkpoint.product_id
        WHERE
            admittance.assignation.bracelet_id = NEW.bracelet_id
            AND admittance.product_checkpoint.checkpoint_id = NEW.checkpoint_id
            AND admittance.assignation.valid_from <= NOW()
            AND admittance.assignation.valid_to >= NOW()
            AND NOT EXISTS (SELECT 1 FROM admittance.assignation_cancelation WHERE assignation_id = assignation.assignation_id)
    ) THEN
        RAISE EXCEPTION 'This bracelet is either invalid, expired or unassigned';
    END IF;
    RETURN NEW;
END;
$$ language 'plpgsql';
CREATE TRIGGER admittance_verify_activation_validation BEFORE INSERT ON admittance.activation
    FOR EACH ROW EXECUTE FUNCTION admittance.activation_validation();

-- DO $$
-- BEGIN

-- code here

    -- FOR counter IN 1..2000 LOOP
    --     INSERT INTO admittance.bracelet (series_name, serial) VALUES ('12', counter);
    -- END LOOP;

-- END; $$
